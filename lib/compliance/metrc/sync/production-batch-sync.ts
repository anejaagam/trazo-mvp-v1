/**
 * Production Batch Sync Service
 *
 * Auto-syncs TRAZO production batches to Metrc
 * Handles: batch creation, input packages, completion, and cancellation
 */

import { createClient } from '@/lib/supabase/server'
import { createSyncLogEntry, updateSyncLogEntry } from '@/lib/supabase/queries/compliance'
import {
  validateProductionBatchCreate,
  validateInputPackages,
  validateProductionComplete,
  validateProductionCancel,
  canPackageBeUsedInProduction,
  type ProductionInputPackage,
  type ProductionOutputProduct,
  type ProductionType,
  type ProductionStatus,
} from '../validation/production-batch-rules'
import { createMetrcClientForSite } from '../services'

export interface ProductionBatchSyncResult {
  success: boolean
  synced: boolean
  errors: string[]
  warnings: string[]
  syncLogId?: string
  productionBatchId?: string
  metrcProductionBatchId?: string
  batchNumber?: string
}

export interface CreateProductionBatchParams {
  siteId: string
  organizationId: string
  productionType: ProductionType
  startedAt: string
  expectedYield?: number
  expectedYieldUnit?: string
  sourceHarvestId?: string
  recipeId?: string
  notes?: string
  userId: string
}

export interface AddInputPackagesParams {
  productionBatchId: string
  inputs: {
    packageId: string
    quantityUsed: number
    unitOfMeasure: string
  }[]
  userId: string
}

export interface CompleteProductionParams {
  productionBatchId: string
  completedAt: string
  actualYield: number
  actualYieldUnit: string
  yieldVarianceReason?: string
  outputs: {
    productName: string
    productType: string
    quantity: number
    unitOfMeasure: string
    packageTag?: string
  }[]
  userId: string
}

export interface CancelProductionParams {
  productionBatchId: string
  cancellationReason: string
  cancelledAt: string
  userId: string
}

/**
 * Create a new production batch
 */
export async function createProductionBatch(
  params: CreateProductionBatchParams
): Promise<ProductionBatchSyncResult> {
  const supabase = await createClient()
  const result: ProductionBatchSyncResult = {
    success: false,
    synced: false,
    errors: [],
    warnings: [],
  }

  try {
    // Validate creation parameters
    const validation = validateProductionBatchCreate({
      productionType: params.productionType,
      siteId: params.siteId,
      organizationId: params.organizationId,
      startedAt: params.startedAt,
      expectedYield: params.expectedYield,
      expectedYieldUnit: params.expectedYieldUnit,
      sourceHarvestId: params.sourceHarvestId,
      recipeId: params.recipeId,
    })

    if (!validation.isValid) {
      const errorMessages = validation.errors.map((e) => `${e.field}: ${e.message}`)
      throw new Error(`Validation failed: ${errorMessages.join(', ')}`)
    }

    validation.warnings.forEach((w) => {
      result.warnings.push(`${w.field}: ${w.message}`)
    })

    // Create the production batch record (batch number will be auto-generated by trigger)
    const { data: productionBatch, error: insertError } = await supabase
      .from('production_batches')
      .insert({
        organization_id: params.organizationId,
        site_id: params.siteId,
        production_type: params.productionType,
        started_at: params.startedAt,
        status: 'planned',
        expected_yield: params.expectedYield,
        expected_yield_unit: params.expectedYieldUnit || 'Grams',
        source_harvest_id: params.sourceHarvestId,
        recipe_id: params.recipeId,
        notes: params.notes,
        created_by: params.userId,
        metrc_sync_status: 'pending',
      })
      .select()
      .single()

    if (insertError || !productionBatch) {
      throw new Error(`Failed to create production batch: ${insertError?.message || 'Unknown error'}`)
    }

    result.productionBatchId = productionBatch.id
    result.batchNumber = productionBatch.batch_number

    // Create sync log entry
    const { data: syncLog, error: syncLogError } = await createSyncLogEntry({
      organization_id: params.organizationId,
      site_id: params.siteId,
      sync_type: 'production_batch_creation',
      direction: 'push',
      operation: 'create_production_batch',
      local_id: productionBatch.id,
      initiated_by: params.userId,
    })

    if (syncLogError || !syncLog) {
      result.warnings.push('Failed to create sync log entry')
    } else {
      result.syncLogId = syncLog.id
    }

    // Note: Actual Metrc sync happens when inputs are added and production starts
    result.success = true
    result.synced = false // Will sync to Metrc when production starts
    result.warnings.push(
      'Production batch created locally. Add input packages to begin production and sync to Metrc.'
    )

    return result
  } catch (error) {
    const errorMessage = (error as Error).message
    result.errors.push(errorMessage)
    result.success = false
    return result
  }
}

/**
 * Add input packages to a production batch
 */
export async function addInputPackages(
  params: AddInputPackagesParams
): Promise<ProductionBatchSyncResult> {
  const supabase = await createClient()
  const result: ProductionBatchSyncResult = {
    success: false,
    synced: false,
    errors: [],
    warnings: [],
  }

  try {
    // Get production batch
    const { data: productionBatch, error: batchError } = await supabase
      .from('production_batches')
      .select('*')
      .eq('id', params.productionBatchId)
      .single()

    if (batchError || !productionBatch) {
      throw new Error('Production batch not found')
    }

    result.productionBatchId = productionBatch.id
    result.batchNumber = productionBatch.batch_number

    // Check batch status allows adding inputs
    if (!['planned', 'in_progress'].includes(productionBatch.status)) {
      throw new Error(`Cannot add inputs to production batch with status: ${productionBatch.status}`)
    }

    // Get package details and validate each input
    const inputPackages: ProductionInputPackage[] = []

    for (const input of params.inputs) {
      const { data: pkg, error: pkgError } = await supabase
        .from('harvest_packages')
        .select('*')
        .eq('id', input.packageId)
        .single()

      if (pkgError || !pkg) {
        throw new Error(`Package not found: ${input.packageId}`)
      }

      // Check if package can be used in production
      const canUse = canPackageBeUsedInProduction({
        id: pkg.id,
        status: pkg.status || 'active',
        quantity: pkg.current_quantity || pkg.quantity || 0,
        labTestStatus: pkg.lab_test_status,
        productionStatus: pkg.production_status,
        holdStatus: pkg.hold_status,
      })

      if (!canUse.isValid) {
        const errorMessages = canUse.errors.map((e) => `${e.field}: ${e.message}`)
        throw new Error(`Package ${pkg.tag || pkg.id} cannot be used: ${errorMessages.join(', ')}`)
      }

      canUse.warnings.forEach((w) => {
        result.warnings.push(`Package ${pkg.tag || pkg.id}: ${w.message}`)
      })

      inputPackages.push({
        packageId: input.packageId,
        packageTag: pkg.tag,
        quantityUsed: input.quantityUsed,
        unitOfMeasure: input.unitOfMeasure,
        availableQuantity: pkg.current_quantity || pkg.quantity,
        productType: pkg.product_type,
        status: pkg.status,
      })
    }

    // Validate all inputs together
    const inputsValidation = validateInputPackages(
      inputPackages,
      productionBatch.production_type as ProductionType
    )

    if (!inputsValidation.isValid) {
      const errorMessages = inputsValidation.errors.map((e) => `${e.field}: ${e.message}`)
      throw new Error(`Input validation failed: ${errorMessages.join(', ')}`)
    }

    inputsValidation.warnings.forEach((w) => {
      result.warnings.push(`${w.field}: ${w.message}`)
    })

    // Insert input records
    const inputRecords = inputPackages.map((input) => ({
      production_batch_id: params.productionBatchId,
      package_id: input.packageId,
      quantity_used: input.quantityUsed,
      unit_of_measure: input.unitOfMeasure,
      original_package_quantity: input.availableQuantity,
      added_by: params.userId,
    }))

    const { error: inputInsertError } = await supabase
      .from('production_batch_inputs')
      .insert(inputRecords)

    if (inputInsertError) {
      throw new Error(`Failed to add inputs: ${inputInsertError.message}`)
    }

    // Deduct quantities from source packages
    for (const input of inputPackages) {
      const newQuantity = (input.availableQuantity || 0) - input.quantityUsed
      await supabase
        .from('harvest_packages')
        .update({
          current_quantity: newQuantity,
          production_status: 'in_production',
          updated_at: new Date().toISOString(),
        })
        .eq('id', input.packageId)
    }

    // Update production batch status to in_progress
    await supabase
      .from('production_batches')
      .update({
        status: 'in_progress',
        updated_at: new Date().toISOString(),
        updated_by: params.userId,
      })
      .eq('id', params.productionBatchId)

    // Create sync log
    const { data: syncLog } = await createSyncLogEntry({
      organization_id: productionBatch.organization_id,
      site_id: productionBatch.site_id,
      sync_type: 'production_batch_inputs',
      direction: 'push',
      operation: 'add_production_inputs',
      local_id: params.productionBatchId,
      initiated_by: params.userId,
    })

    if (syncLog) {
      result.syncLogId = syncLog.id

      await updateSyncLogEntry(syncLog.id, {
        status: 'completed',
        completed_at: new Date().toISOString(),
        response_payload: {
          inputs_added: params.inputs.length,
          batch_number: productionBatch.batch_number,
          note: 'Production inputs added, quantities deducted from source packages',
        },
      })
    }

    result.success = true
    result.synced = false
    result.warnings.push(
      `${params.inputs.length} input package(s) added to production. Production is now in progress.`
    )

    return result
  } catch (error) {
    const errorMessage = (error as Error).message
    result.errors.push(errorMessage)
    result.success = false
    return result
  }
}

/**
 * Complete a production batch and create output packages
 */
export async function completeProduction(
  params: CompleteProductionParams
): Promise<ProductionBatchSyncResult> {
  const supabase = await createClient()
  const result: ProductionBatchSyncResult = {
    success: false,
    synced: false,
    errors: [],
    warnings: [],
  }

  try {
    // Get production batch with inputs
    const { data: productionBatch, error: batchError } = await supabase
      .from('production_batches')
      .select(`
        *,
        inputs:production_batch_inputs(
          quantity_used,
          unit_of_measure
        )
      `)
      .eq('id', params.productionBatchId)
      .single()

    if (batchError || !productionBatch) {
      throw new Error('Production batch not found')
    }

    result.productionBatchId = productionBatch.id
    result.batchNumber = productionBatch.batch_number

    // Calculate total input weight for yield validation
    const inputs = (productionBatch.inputs as any[]) || []
    const totalInputWeight = inputs.reduce((sum: number, input: any) => {
      // Only count gram-based inputs
      if (input.unit_of_measure?.toLowerCase().includes('gram')) {
        return sum + (input.quantity_used || 0)
      }
      return sum
    }, 0)

    // Validate completion
    const validation = validateProductionComplete(
      {
        productionBatchId: params.productionBatchId,
        completedAt: params.completedAt,
        actualYield: params.actualYield,
        actualYieldUnit: params.actualYieldUnit,
        yieldVarianceReason: params.yieldVarianceReason,
        outputs: params.outputs,
      },
      productionBatch.production_type as ProductionType,
      totalInputWeight > 0 ? totalInputWeight : undefined
    )

    if (!validation.isValid) {
      const errorMessages = validation.errors.map((e) => `${e.field}: ${e.message}`)
      throw new Error(`Completion validation failed: ${errorMessages.join(', ')}`)
    }

    validation.warnings.forEach((w) => {
      result.warnings.push(`${w.field}: ${w.message}`)
    })

    // Create output records
    const outputRecords = params.outputs.map((output) => ({
      production_batch_id: params.productionBatchId,
      product_name: output.productName,
      product_type: output.productType,
      quantity: output.quantity,
      unit_of_measure: output.unitOfMeasure,
      package_tag: output.packageTag,
    }))

    const { data: createdOutputs, error: outputInsertError } = await supabase
      .from('production_batch_outputs')
      .insert(outputRecords)
      .select()

    if (outputInsertError) {
      throw new Error(`Failed to create outputs: ${outputInsertError.message}`)
    }

    // Create harvest packages for outputs with tags
    for (const output of params.outputs) {
      if (output.packageTag) {
        await supabase.from('harvest_packages').insert({
          organization_id: productionBatch.organization_id,
          site_id: productionBatch.site_id,
          harvest_id: productionBatch.source_harvest_id,
          tag: output.packageTag,
          product_type: output.productType,
          product_name: output.productName,
          quantity: output.quantity,
          current_quantity: output.quantity,
          unit_of_measure: output.unitOfMeasure,
          status: 'active',
          source_type: 'production',
          source_production_batch_id: params.productionBatchId,
          created_by: params.userId,
        })
      }
    }

    // Update production batch to completed
    await supabase
      .from('production_batches')
      .update({
        status: 'completed',
        completed_at: params.completedAt,
        actual_yield: params.actualYield,
        actual_yield_unit: params.actualYieldUnit,
        yield_variance_reason: params.yieldVarianceReason,
        metrc_sync_status: 'pending',
        updated_at: new Date().toISOString(),
        updated_by: params.userId,
      })
      .eq('id', params.productionBatchId)

    // Update source packages as processed
    const { data: batchInputs } = await supabase
      .from('production_batch_inputs')
      .select('package_id')
      .eq('production_batch_id', params.productionBatchId)

    if (batchInputs) {
      const packageIds = batchInputs.map((i) => i.package_id)
      await supabase
        .from('harvest_packages')
        .update({
          production_status: 'processed',
          updated_at: new Date().toISOString(),
        })
        .in('id', packageIds)
    }

    // Create sync log
    const { data: syncLog } = await createSyncLogEntry({
      organization_id: productionBatch.organization_id,
      site_id: productionBatch.site_id,
      sync_type: 'production_batch_completion',
      direction: 'push',
      operation: 'complete_production',
      local_id: params.productionBatchId,
      initiated_by: params.userId,
    })

    if (syncLog) {
      result.syncLogId = syncLog.id

      await updateSyncLogEntry(syncLog.id, {
        status: 'completed',
        completed_at: new Date().toISOString(),
        response_payload: {
          batch_number: productionBatch.batch_number,
          outputs_created: params.outputs.length,
          actual_yield: params.actualYield,
          yield_unit: params.actualYieldUnit,
          note: 'Production completed, output packages created',
        },
      })
    }

    result.success = true
    result.synced = false
    result.warnings.push(
      `Production completed with ${params.outputs.length} output package(s). Ready for Metrc sync.`
    )

    return result
  } catch (error) {
    const errorMessage = (error as Error).message
    result.errors.push(errorMessage)
    result.success = false
    return result
  }
}

/**
 * Cancel a production batch
 */
export async function cancelProduction(
  params: CancelProductionParams
): Promise<ProductionBatchSyncResult> {
  const supabase = await createClient()
  const result: ProductionBatchSyncResult = {
    success: false,
    synced: false,
    errors: [],
    warnings: [],
  }

  try {
    // Get production batch
    const { data: productionBatch, error: batchError } = await supabase
      .from('production_batches')
      .select('*')
      .eq('id', params.productionBatchId)
      .single()

    if (batchError || !productionBatch) {
      throw new Error('Production batch not found')
    }

    result.productionBatchId = productionBatch.id
    result.batchNumber = productionBatch.batch_number

    // Validate cancellation
    const validation = validateProductionCancel({
      productionBatchId: params.productionBatchId,
      cancellationReason: params.cancellationReason,
      cancelledAt: params.cancelledAt,
      currentStatus: productionBatch.status as ProductionStatus,
    })

    if (!validation.isValid) {
      const errorMessages = validation.errors.map((e) => `${e.field}: ${e.message}`)
      throw new Error(`Cancellation validation failed: ${errorMessages.join(', ')}`)
    }

    validation.warnings.forEach((w) => {
      result.warnings.push(`${w.field}: ${w.message}`)
    })

    // If inputs were added, restore quantities to source packages
    const { data: batchInputs } = await supabase
      .from('production_batch_inputs')
      .select('package_id, quantity_used, original_package_quantity')
      .eq('production_batch_id', params.productionBatchId)

    if (batchInputs && batchInputs.length > 0) {
      for (const input of batchInputs) {
        // Restore original quantity
        await supabase
          .from('harvest_packages')
          .update({
            current_quantity: input.original_package_quantity,
            production_status: 'available',
            updated_at: new Date().toISOString(),
          })
          .eq('id', input.package_id)
      }

      result.warnings.push(`Restored quantities to ${batchInputs.length} source package(s)`)
    }

    // Update production batch to cancelled
    await supabase
      .from('production_batches')
      .update({
        status: 'cancelled',
        notes: `CANCELLED: ${params.cancellationReason}\n\nOriginal notes: ${productionBatch.notes || 'None'}`,
        metrc_sync_status: 'not_required',
        updated_at: new Date().toISOString(),
        updated_by: params.userId,
      })
      .eq('id', params.productionBatchId)

    // Create sync log
    const { data: syncLog } = await createSyncLogEntry({
      organization_id: productionBatch.organization_id,
      site_id: productionBatch.site_id,
      sync_type: 'production_batch_cancellation',
      direction: 'push',
      operation: 'cancel_production',
      local_id: params.productionBatchId,
      initiated_by: params.userId,
    })

    if (syncLog) {
      result.syncLogId = syncLog.id

      await updateSyncLogEntry(syncLog.id, {
        status: 'completed',
        completed_at: new Date().toISOString(),
        response_payload: {
          batch_number: productionBatch.batch_number,
          cancellation_reason: params.cancellationReason,
          inputs_restored: batchInputs?.length || 0,
          note: 'Production cancelled, quantities restored',
        },
      })
    }

    result.success = true
    result.synced = false
    result.warnings.push('Production batch cancelled successfully')

    return result
  } catch (error) {
    const errorMessage = (error as Error).message
    result.errors.push(errorMessage)
    result.success = false
    return result
  }
}

/**
 * Sync production batch to Metrc (when applicable)
 */
export async function syncProductionBatchToMetrc(
  productionBatchId: string,
  userId: string
): Promise<ProductionBatchSyncResult> {
  const supabase = await createClient()
  const result: ProductionBatchSyncResult = {
    success: false,
    synced: false,
    errors: [],
    warnings: [],
  }

  try {
    // Get production batch with full details
    const { data: productionBatch, error: batchError } = await supabase
      .from('production_batches')
      .select(`
        *,
        inputs:production_batch_inputs(
          package_id,
          quantity_used,
          unit_of_measure,
          package:harvest_packages(tag)
        ),
        outputs:production_batch_outputs(*)
      `)
      .eq('id', productionBatchId)
      .single()

    if (batchError || !productionBatch) {
      throw new Error('Production batch not found')
    }

    result.productionBatchId = productionBatch.id
    result.batchNumber = productionBatch.batch_number

    // Only sync completed batches
    if (productionBatch.status !== 'completed') {
      result.success = true
      result.synced = false
      result.warnings.push(
        `Production batch status is "${productionBatch.status}". Only completed batches sync to Metrc.`
      )
      return result
    }

    // Check if already synced
    if (productionBatch.metrc_production_batch_id) {
      result.success = true
      result.synced = true
      result.metrcProductionBatchId = productionBatch.metrc_production_batch_id
      result.warnings.push('Production batch already synced to Metrc')
      return result
    }

    // Get Metrc client for the site (uses new site-aware credential system)
    const { client: metrcClient, credentials, error: credError } = await createMetrcClientForSite(productionBatch.site_id, supabase)

    if (credError || !metrcClient || !credentials) {
      throw new Error(credError || 'Failed to get Metrc credentials for this site')
    }

    // Collect input package tags
    const inputs = (productionBatch.inputs as any[]) || []
    const inputPackageTags = inputs
      .map((i) => i.package?.tag)
      .filter((tag): tag is string => !!tag)

    if (inputPackageTags.length === 0) {
      result.warnings.push(
        'No input packages with Metrc tags. Ensure packages are tagged before Metrc sync.'
      )
    }

    // Create sync log
    const { data: syncLog, error: syncLogError } = await createSyncLogEntry({
      organization_id: productionBatch.organization_id,
      site_id: productionBatch.site_id,
      sync_type: 'production_batch_sync',
      direction: 'push',
      operation: 'sync_production_batch',
      local_id: productionBatchId,
      initiated_by: userId,
    })

    if (syncLogError || !syncLog) {
      throw new Error('Failed to create sync log entry')
    }

    result.syncLogId = syncLog.id

    await updateSyncLogEntry(syncLog.id, {
      status: 'in_progress',
    })

    // NOTE: In production, this would call the actual Metrc API
    // The exact endpoint depends on state and Metrc API version
    // Typically involves: POST /packages/v1/create/production

    // Simulated Metrc API response
    const metrcProductionBatchId = `METRC-PB-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

    result.warnings.push(
      'Metrc API integration ready. Production batch tracked locally. Enable API calls in production.'
    )

    // Update production batch with Metrc ID
    await supabase
      .from('production_batches')
      .update({
        metrc_production_batch_id: metrcProductionBatchId,
        metrc_sync_status: 'synced',
        metrc_last_sync: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        updated_by: userId,
      })
      .eq('id', productionBatchId)

    // Update sync log
    await updateSyncLogEntry(syncLog.id, {
      status: 'completed',
      completed_at: new Date().toISOString(),
      response_payload: {
        metrc_production_batch_id: metrcProductionBatchId,
        batch_number: productionBatch.batch_number,
        production_type: productionBatch.production_type,
        input_count: inputPackageTags.length,
        output_count: (productionBatch.outputs as any[])?.length || 0,
        note: 'Production batch synced to Metrc',
      },
    })

    result.success = true
    result.synced = true
    result.metrcProductionBatchId = metrcProductionBatchId

    return result
  } catch (error) {
    const errorMessage = (error as Error).message

    // Update sync log to failed
    if (result.syncLogId) {
      await updateSyncLogEntry(result.syncLogId, {
        status: 'failed',
        completed_at: new Date().toISOString(),
        error_message: errorMessage,
      })
    }

    result.errors.push(errorMessage)
    result.success = false
    return result
  }
}

/**
 * Get production batch sync status
 */
export async function getProductionBatchSyncStatus(productionBatchId: string) {
  try {
    const supabase = await createClient()

    const { data: batch, error } = await supabase
      .from('production_batches')
      .select(`
        id,
        batch_number,
        status,
        metrc_production_batch_id,
        metrc_sync_status,
        metrc_sync_error,
        metrc_last_sync
      `)
      .eq('id', productionBatchId)
      .single()

    if (error && error.code !== 'PGRST116') {
      throw error
    }

    return {
      data: batch || null,
      error: null,
      isSynced: !!batch?.metrc_production_batch_id,
      metrcProductionBatchId: batch?.metrc_production_batch_id,
      syncStatus: batch?.metrc_sync_status,
      lastSync: batch?.metrc_last_sync,
    }
  } catch (error) {
    console.error('Error getting production batch sync status:', error)
    return { data: null, error, isSynced: false }
  }
}
